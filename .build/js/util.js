// Generated by CoffeeScript 1.4.0
(function() {
  var applyAttrs, axis, mathText, partialCircle, rotatedLine, tspan, turnRotate,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.τ = 2 * Math.PI;

  this.callbackAfter = function(fn, delay) {
    return function() {
      return setTimeout(fn, delay);
    };
  };

  this.Bound = (function() {

    function Bound(end, open) {
      this.end = end;
      this.open = open != null ? open : true;
    }

    return Bound;

  })();

  this.Path = (function() {

    function Path(x, y) {
      this.arc = __bind(this.arc, this);

      this.symmetricArc = __bind(this.symmetricArc, this);

      this.move = __bind(this.move, this);

      this.draw = __bind(this.draw, this);
      this.string = "M " + x + " " + y;
    }

    Path.prototype.draw = function(x, y, options) {
      var letter;
      letter = (options != null ? options.absolute : void 0) ? 'L' : 'l';
      this.string += "" + letter + " " + x + " " + y;
      return this;
    };

    Path.prototype.move = function(x, y, options) {
      var letter;
      letter = (options != null ? options.absolute : void 0) ? 'M' : 'm';
      this.string += "" + letter + " " + x + " " + y;
      return this;
    };

    Path.prototype.symmetricArc = function(x, y, r, options) {
      this.arc(x, y, r, r, 0, options);
      return this;
    };

    Path.prototype.arc = function(x, y, rx, ry, theta, options) {
      var invert, large, letter;
      large = +((options != null ? options.large : void 0) || 0);
      invert = +((options != null ? options.invert : void 0) || 0);
      letter = (options != null ? options.absolute : void 0) ? 'A' : 'a';
      this.string += "" + letter + " " + rx + " " + ry + " " + theta + " " + large + " " + invert + " " + x + " " + y;
      return this;
    };

    return Path;

  })();

  partialCircle = function(cx, cy, r, turns, yaw) {
    var x1, x2, y1, y2;
    yaw = yaw || 0;
    x1 = cx + (r * Math.cos(yaw * τ));
    y1 = cy - (r * Math.sin(yaw * τ));
    x2 = cx + (r * Math.cos((yaw + turns) * τ));
    y2 = cy - (r * Math.sin((yaw + turns) * τ));
    return new Path(x1, y1).symmetricArc(x2, y2, r, {
      large: turns > 0.5,
      absolute: true
    });
  };

  rotatedLine = function(sx, sy, r, turns) {
    var dx, dy;
    dx = r * Math.cos(turns * τ);
    dy = -r * Math.sin(turns * τ);
    return new Path(sx, sy).draw(dx, dy);
  };

  turnRotate = function(cx, cy, uplen, downlen, turns) {
    var h, v, x1, x2, y1, y2;
    h = Math.cos(τ * turns);
    v = -Math.sin(τ * turns);
    x1 = cx + uplen * h;
    y1 = cy + uplen * v;
    x2 = cx - downlen * h;
    y2 = cy - downlen * v;
    return new Path(x1, y1).draw(x2, y2, {
      absolute: true
    });
  };

  applyAttrs = function(obj, attrs) {
    var node;
    node = $(obj.node);
    if (attrs == null) {
      attrs = {};
    }
    if (_.isArray(attrs["class"])) {
      node.attr('class', attrs["class"].join(' '));
    } else if (_.isString(attrs["class"])) {
      node.attr('class', attrs["class"]);
    }
    delete attrs["class"];
    if (_.isString(attrs.style)) {
      node.attr('style', attrs.style);
    }
    delete attrs.style;
    if (!_.isEmpty(attrs)) {
      obj.attr(attrs);
    }
    return obj;
  };

  tspan = function(part) {
    var key, node, val;
    node = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
    if (_.isObject(part)) {
      node.appendChild(document.createTextNode(part.text));
      delete part.text;
      for (key in part) {
        val = part[key];
        node.setAttribute(key, val);
      }
    } else {
      node.appendChild(document.createTextNode(part));
    }
    return node;
  };

  mathText = function(paper, x, y, parts, attrs) {
    var elem;
    if (_.isArray(parts)) {
      elem = paper.text(x, y, '');
      _.each(parts, function(part) {
        return elem.node.appendChild(tspan(part));
      });
    } else {
      elem = paper.text(x, y, parts);
    }
    elem.node.removeAttribute('style');
    return applyAttrs(elem, attrs);
  };

  axis = function(paper, zx, zy, options) {
    var cap, ex, ey, geometry, hasPath, label, labels, length, n, neglength, negticks, negunits, number, path, position, poslength, posticks, posunits, stepWidth, sx, sy, tick, turns, tx, ty, ux, uy, _i, _j, _len, _len1, _ref, _ref1;
    options = _.defaults(options || {}, {
      arrowBreadth: 1 / 2,
      arrowClass: 'arrow',
      arrowLength: 2,
      capLength: 1,
      classes: ['axis'],
      doTick: true,
      from: null,
      labelClass: '',
      labels: {},
      lineClass: '',
      step: 1,
      swapLabels: false,
      textOffset: 7,
      tickClass: 'tick',
      tickHeight: 4,
      tickType: 'T',
      to: new Bound(10, true),
      turns: 0,
      unit: 10,
      zero: 0,
      zeroTick: true,
      zeroLabel: true
    });
    geometry = paper.set();
    labels = paper.set();
    options.zero = +options.zero;
    if (options.from == null) {
      options.from = new Bound(options.zero, false);
    }
    if (_.isNumber(options.from)) {
      options.from = new Bound(options.from);
    }
    if (_.isNumber(options.to)) {
      options.to = new Bound(options.to);
    }
    if (_.isArray(options.classes)) {
      options.classes = options.classes.join(' ');
    }
    if (_.isBoolean(options.zeroTick) && ((_ref = options.tickType) === '|' || _ref === '+')) {
      options.zeroTick = options.zeroTick ? 1.5 : 1;
    }
    options.arrowBreadth = options.arrowBreadth * options.tickHeight;
    options.arrowLength = options.arrowLength * options.tickHeight;
    stepWidth = options.unit * options.step;
    posunits = options.to.end - options.zero;
    posticks = ((function() {
      var _i, _ref1, _ref2, _ref3, _results;
      _results = [];
      for (n = _i = _ref1 = options.zero, _ref2 = options.to.end, _ref3 = options.step; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; n = _i += _ref3) {
        _results.push(n);
      }
      return _results;
    })()).slice(1);
    poslength = posunits * options.unit;
    if (options.to.open) {
      poslength += options.capLength * options.unit - options.arrowLength;
    }
    negunits = options.zero - options.from.end;
    negticks = (function() {
      var _i, _ref1, _ref2, _ref3, _results;
      _results = [];
      for (n = _i = _ref1 = options.from.end, _ref2 = options.zero, _ref3 = options.step; _ref1 <= _ref2 ? _i < _ref2 : _i > _ref2; n = _i += _ref3) {
        _results.push(n);
      }
      return _results;
    })();
    neglength = negunits * options.unit;
    if (options.from.open) {
      neglength += options.capLength * options.unit - options.arrowLength;
    }
    turns = τ * options.turns;
    length = neglength + poslength;
    ux = Math.cos(turns);
    uy = Math.sin(turns);
    sx = zx - (neglength * ux);
    sy = zy + (neglength * uy);
    ex = zx + (poslength * ux);
    ey = zy - (poslength * uy);
    hasPath = (_ref1 = options.tickType) === 'T' || _ref1 === 'L' || _ref1 === '+' || _ref1 === false;
    if (hasPath) {
      path = paper.path(['M', sx, sy, 'L', ex, ey]);
      $(path.node).attr({
        'class': "" + options.classes + " " + options.lineClass
      });
      geometry.push(path);
    }
    label = function(tx, ty, number) {
      var elem, elemAttrs, labelParts;
      if (options.labels === false) {
        return;
      }
      labelParts = _.isFunction(options.labels) ? options.labels(number) : _.has(options.labels, number) ? options.labels[number] : number;
      if (!(labelParts != null)) {
        return;
      }
      elemAttrs = {
        "class": "" + options.classes + " " + options.labelClass
      };
      elem = mathText(paper, tx, ty, labelParts, elemAttrs);
      return labels.push(elem);
    };
    tick = function(cx, cy, number, zero) {
      var bottom, botx, boty, factor, full, textx, texty, tickLine, toff, top, topx, topy, _ref2;
      if (zero == null) {
        zero = false;
      }
      if (zero && options.zeroTick === 0) {
        return;
      }
      if (_.isFunction(options.doTick) && !options.doTick(number)) {
        return;
      }
      if (options.tickType === ' ') {
        textx = cx + options.textOffset * uy;
        texty = cy + options.textOffset * ux;
        if (!(zero && !options.zeroLabel)) {
          label(textx, texty, number);
        }
        return;
      }
      if (options.tickType === false) {
        return;
      }
      full = (_ref2 = options.tickType) === '|' || _ref2 === '+';
      factor = 1;
      if (zero && full) {
        factor = options.zeroTick;
      } else if (zero && options.zeroTick) {
        full = true;
        factor = 2;
      }
      if (full) {
        top = factor * 1 / 2;
        bottom = factor * 1 / 2;
      } else if (options.tickType === 'L') {
        top = factor;
        bottom = 0;
      } else {
        top = 0;
        bottom = factor;
      }
      topx = cx - (options.tickHeight * top * uy);
      topy = cy - (options.tickHeight * top * ux);
      botx = cx + (options.tickHeight * bottom * uy);
      boty = cy + (options.tickHeight * bottom * ux);
      toff = options.tickHeight + options.textOffset;
      if (options.swapLabels) {
        toff *= -1;
      }
      textx = cx + (toff * uy);
      texty = cy + (toff * ux);
      if (!(zero && !options.zeroLabel)) {
        label(textx, texty, number);
      }
      tickLine = paper.path(['M', topx, topy, 'L', botx, boty]);
      $(tickLine.node).attr({
        "class": "" + options.classes + " " + options.tickClass
      });
      return geometry.push(tickLine);
    };
    for (position = _i = 0, _len = negticks.length; _i < _len; position = ++_i) {
      number = negticks[position];
      tx = zx - ((negticks.length - position) * stepWidth * ux);
      ty = zy + ((negticks.length - position) * stepWidth * uy);
      tick(tx, ty, number);
    }
    tick(zx, zy, options.zero, true);
    for (position = _j = 0, _len1 = posticks.length; _j < _len1; position = ++_j) {
      number = posticks[position];
      tx = zx + ((position + 1) * stepWidth * ux);
      ty = zy - ((position + 1) * stepWidth * uy);
      tick(tx, ty, number);
    }
    cap = function(cx, cy, invert) {
      var arrow, db, dl;
      if (invert == null) {
        invert = false;
      }
      dl = invert ? -options.arrowLength : options.arrowLength;
      db = options.arrowBreadth;
      arrow = paper.path(['M', cx + dl * ux, cy - dl * uy, cx - db * uy, cy - db * ux, cx + db * uy, cy + db * ux, 'z']);
      $(arrow.node).attr({
        "class": "" + options.classes + " " + options.arrowClass
      });
      return geometry.push(arrow);
    };
    if (options.from.open) {
      cap(sx, sy, true);
    }
    if (options.to.open) {
      cap(ex, ey);
    }
    return [geometry, labels];
  };

  this.Diagram = (function() {

    function Diagram(elem, width, height) {
      var aspect, trueWidth;
      this.elem = elem;
      this.text = __bind(this.text, this);

      this.axis = __bind(this.axis, this);

      this.elem = $(elem);
      trueWidth = this.elem.width();
      aspect = height / width;
      this.paper = new Raphael(elem, trueWidth, trueWidth * aspect);
      this.paper.customAttributes.partialCircle = function(x, y, r, turns, yaw) {
        var path;
        path = partialCircle(x, y, r, turns, yaw);
        return {
          path: path.string
        };
      };
      this.paper.customAttributes.turnRotate = function(x, y, uplen, downlen, turns) {
        return {
          path: turnRotate(x, y, uplen, downlen, turns).string
        };
      };
      this.paper.customAttributes.turnText = function(turns) {
        return {
          text: (τ * turns).toFixed(6)
        };
      };
      this.paper.setViewBox(0, 0, width, height);
    }

    Diagram.prototype.circle = function(attrs) {
      return applyAttrs(this.paper.circle(), attrs);
    };

    Diagram.prototype.path = function(attrs) {
      return applyAttrs(this.paper.path(), attrs);
    };

    Diagram.prototype.axis = function(zx, zy, options) {
      return axis(this.paper, zx, zy, options);
    };

    Diagram.prototype.text = function(x, y, parts, attrs) {
      return mathText(this.paper, x, y, parts, attrs);
    };

    return Diagram;

  })();

  this.diagram = function(codename, cls, w, h) {
    return $("." + codename).each(function() {
      return new cls(this, w, h).start();
    });
  };

}).call(this);
