// Generated by CoffeeScript 1.4.0
(function() {
  var axisArrow, partialCircle, rotatedLine, turnRotate,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.τ = 2 * Math.PI;

  this.Path = (function() {

    function Path(x, y) {
      this.arc = __bind(this.arc, this);

      this.symmetricArc = __bind(this.symmetricArc, this);

      this.move = __bind(this.move, this);

      this.draw = __bind(this.draw, this);
      this.string = "M " + x + " " + y;
    }

    Path.prototype.draw = function(x, y, options) {
      var letter;
      letter = (options != null ? options.absolute : void 0) ? 'L' : 'l';
      this.string += "" + letter + " " + x + " " + y;
      return this;
    };

    Path.prototype.move = function(x, y, options) {
      var letter;
      letter = (options != null ? options.absolute : void 0) ? 'M' : 'm';
      this.string += "" + letter + " " + x + " " + y;
      return this;
    };

    Path.prototype.symmetricArc = function(x, y, r, options) {
      this.arc(x, y, r, r, 0, options);
      return this;
    };

    Path.prototype.arc = function(x, y, rx, ry, theta, options) {
      var invert, large, letter;
      large = +((options != null ? options.large : void 0) || 0);
      invert = +((options != null ? options.invert : void 0) || 0);
      letter = (options != null ? options.absolute : void 0) ? 'A' : 'a';
      this.string += "" + letter + " " + rx + " " + ry + " " + theta + " " + large + " " + invert + " " + x + " " + y;
      return this;
    };

    return Path;

  })();

  partialCircle = function(cx, cy, r, turns, yaw) {
    var x1, x2, y1, y2;
    yaw = yaw || 0;
    x1 = cx + (r * Math.cos(yaw * τ));
    y1 = cy - (r * Math.sin(yaw * τ));
    x2 = cx + (r * Math.cos((yaw + turns) * τ));
    y2 = cy - (r * Math.sin((yaw + turns) * τ));
    return new Path(x1, y1).symmetricArc(x2, y2, r, {
      large: turns > 0.5,
      absolute: true
    });
  };

  rotatedLine = function(sx, sy, r, turns) {
    var dx, dy;
    dx = r * Math.cos(turns * τ);
    dy = -r * Math.sin(turns * τ);
    return new Path(sx, sy).draw(dx, dy);
  };

  turnRotate = function(cx, cy, uplen, downlen, turns) {
    var h, v, x1, x2, y1, y2;
    h = Math.cos(τ * turns);
    v = -Math.sin(τ * turns);
    x1 = cx + uplen * h;
    y1 = cy + uplen * v;
    x2 = cx - downlen * h;
    y2 = cy - downlen * v;
    return new Path(x1, y1).draw(x2, y2, {
      absolute: true
    });
  };

  axisArrow = function(paper, x, y, width, right) {
    var axis, dx, dy, ex, ey, path, sx, sy;
    if (right) {
      dx = 8;
      dy = 2;
      ex = x + width;
      ey = y + 0.5;
      axis = paper.path("M" + x + " " + ey + "l" + (width - dx) + " 0");
      $(axis.node).attr('class', 'axis-line');
      path = paper.path("M" + ex + " " + ey + " " + (ex - dx) + " " + (ey - dy) + " " + (ex - dx) + " " + (ey + dy) + "z");
      return $(path.node).attr('class', 'axis-arrow');
    } else {
      dx = 8;
      dy = 2;
      sx = x;
      sy = y + 0.5;
      axis = paper.path("M" + (x + dx) + " " + sy + "l" + (width - dx) + " 0");
      $(axis.node).attr('class', 'axis-line');
      path = paper.path("M" + sx + " " + sy + " " + (sx + dx) + " " + (sy + dy) + " " + (sx + dx) + " " + (sy - dy) + "z");
      return $(path.node).attr('class', 'axis-arrow');
    }
  };

  this.Diagram = (function() {

    function Diagram(elem, width, height) {
      var aspect, trueWidth;
      this.elem = elem;
      this.axis = __bind(this.axis, this);

      this.elem = $(elem);
      trueWidth = this.elem.width();
      aspect = height / width;
      this.paper = new Raphael(elem, trueWidth, trueWidth * aspect);
      this.paper.customAttributes.partialCircle = function(x, y, r, turns, yaw) {
        var path;
        path = partialCircle(x, y, r, turns, yaw);
        return {
          path: path.string
        };
      };
      this.paper.customAttributes.turnRotate = function(x, y, uplen, downlen, turns) {
        return {
          path: turnRotate(x, y, uplen, downlen, turns).string
        };
      };
      this.paper.customAttributes.turnText = function(turns) {
        return {
          text: (τ * turns).toFixed(6)
        };
      };
      this.paper.setViewBox(0, 0, width, height);
    }

    Diagram.prototype.axis = function(startx, starty, tickWidth, tickCount, options) {
      var capFraction, dashsize, end, ends, endx, endy, labels, length, orientation, start, starts, tick, type,
        _this = this;
      length = tickWidth * tickCount;
      start = (options != null ? options.start : void 0) || 0;
      end = (options != null ? options.end : void 0) || tickCount;
      orientation = (options != null ? options.orientation : void 0) || 0;
      labels = (options != null ? options.labels : void 0) || null;
      type = (options != null ? options.type : void 0) || 't';
      dashsize = options != null ? options.dashsize : void 0;
      starts = (options != null ? options.starts : void 0) || true;
      ends = (options != null ? options.ends : void 0) || false;
      capFraction = (options != null ? options.capFraction : void 0) || 1;
      Raphael.g.axis(startx, starty, length, start, end, tickCount, orientation, labels, type, dashsize, this.paper);
      tick = function(x, y) {
        return _this.paper.path("M" + (x + 0.5) + " " + (y + 0.5) + "l0 -4");
      };
      endx = orientation % 2 ? startx : startx + length;
      endy = orientation % 2 ? starty - length : starty;
      if (starts) {
        tick(startx, starty);
      } else {
        axisArrow(this.paper, endx, endy, tickWidth * capFraction, 0);
      }
      if (ends) {
        return tick(endx, endy);
      } else {
        return axisArrow(this.paper, endx, endy, tickWidth * capFraction, 1);
      }
    };

    return Diagram;

  })();

  this.diagram = function(codename, cls, w, h) {
    return $("." + codename).each(function() {
      return new cls(this, w, h).start();
    });
  };

}).call(this);
