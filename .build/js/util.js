// Generated by CoffeeScript 1.4.0
(function() {
  var applyAttrs, axis, partialCircle, rotatedLine, turnRotate,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.τ = 2 * Math.PI;

  this.Bound = (function() {

    function Bound(end, open) {
      this.end = end;
      this.open = open != null ? open : true;
    }

    return Bound;

  })();

  this.Path = (function() {

    function Path(x, y) {
      this.arc = __bind(this.arc, this);

      this.symmetricArc = __bind(this.symmetricArc, this);

      this.move = __bind(this.move, this);

      this.draw = __bind(this.draw, this);
      this.string = "M " + x + " " + y;
    }

    Path.prototype.draw = function(x, y, options) {
      var letter;
      letter = (options != null ? options.absolute : void 0) ? 'L' : 'l';
      this.string += "" + letter + " " + x + " " + y;
      return this;
    };

    Path.prototype.move = function(x, y, options) {
      var letter;
      letter = (options != null ? options.absolute : void 0) ? 'M' : 'm';
      this.string += "" + letter + " " + x + " " + y;
      return this;
    };

    Path.prototype.symmetricArc = function(x, y, r, options) {
      this.arc(x, y, r, r, 0, options);
      return this;
    };

    Path.prototype.arc = function(x, y, rx, ry, theta, options) {
      var invert, large, letter;
      large = +((options != null ? options.large : void 0) || 0);
      invert = +((options != null ? options.invert : void 0) || 0);
      letter = (options != null ? options.absolute : void 0) ? 'A' : 'a';
      this.string += "" + letter + " " + rx + " " + ry + " " + theta + " " + large + " " + invert + " " + x + " " + y;
      return this;
    };

    return Path;

  })();

  partialCircle = function(cx, cy, r, turns, yaw) {
    var x1, x2, y1, y2;
    yaw = yaw || 0;
    x1 = cx + (r * Math.cos(yaw * τ));
    y1 = cy - (r * Math.sin(yaw * τ));
    x2 = cx + (r * Math.cos((yaw + turns) * τ));
    y2 = cy - (r * Math.sin((yaw + turns) * τ));
    return new Path(x1, y1).symmetricArc(x2, y2, r, {
      large: turns > 0.5,
      absolute: true
    });
  };

  rotatedLine = function(sx, sy, r, turns) {
    var dx, dy;
    dx = r * Math.cos(turns * τ);
    dy = -r * Math.sin(turns * τ);
    return new Path(sx, sy).draw(dx, dy);
  };

  turnRotate = function(cx, cy, uplen, downlen, turns) {
    var h, v, x1, x2, y1, y2;
    h = Math.cos(τ * turns);
    v = -Math.sin(τ * turns);
    x1 = cx + uplen * h;
    y1 = cy + uplen * v;
    x2 = cx - downlen * h;
    y2 = cy - downlen * v;
    return new Path(x1, y1).draw(x2, y2, {
      absolute: true
    });
  };

  applyAttrs = function(obj, attrs) {
    var node;
    node = $(obj.node);
    if (_.isArray(attrs != null ? attrs["class"] : void 0)) {
      node.attr('class', attrs["class"].join(' '));
    } else if (_.isString(attrs != null ? attrs["class"] : void 0)) {
      node.attr('class', attrs["class"]);
    }
    delete attrs["class"];
    if (_.isString(attrs != null ? attrs.style : void 0)) {
      node.attr('style', attrs.style);
    }
    delete attrs.style;
    return obj.attr(attrs);
  };

  axis = function(paper, zx, zy, options) {
    var cap, ex, ey, hasPath, label, length, n, neglength, negticks, negunits, number, path, position, poslength, posticks, posunits, sx, sy, tick, turns, tx, ty, ux, uy, _i, _j, _len, _len1, _ref, _ref1;
    options = _.defaults(options || {}, {
      arrowBreadth: 1 / 2,
      arrowClass: 'arrow',
      arrowLength: 2,
      capLength: 1,
      classes: ['axis'],
      from: new Bound(0, false),
      labelClass: '',
      labels: {},
      lineClass: '',
      step: 1,
      swapLabels: false,
      textOffset: 7,
      tickClass: 'tick',
      tickHeight: 4,
      tickType: 'T',
      to: new Bound(10, true),
      turns: 0,
      unit: 10,
      zero: 0,
      zeroTick: true
    });
    if (_.isNumber(options.from)) {
      options.from = new Bound(options.from);
    }
    if (_.isNumber(options.to)) {
      options.to = new Bound(options.to);
    }
    if (_.isArray(options.classes)) {
      options.classes = options.classes.join(' ');
    }
    if (_.isBoolean(options.zeroTick) && options.zeroTick && ((_ref = options.tickType) === '|' || _ref === '+')) {
      options.zeroTick = 1.5;
    }
    options.arrowBreadth = options.arrowBreadth * options.tickHeight;
    options.arrowLength = options.arrowLength * options.tickHeight;
    posunits = options.to.end - options.zero;
    posticks = ((function() {
      var _i, _ref1, _ref2, _ref3, _results;
      _results = [];
      for (n = _i = _ref1 = options.zero, _ref2 = options.to.end, _ref3 = options.step; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; n = _i += _ref3) {
        _results.push(n);
      }
      return _results;
    })()).slice(1);
    poslength = posunits * options.unit;
    if (options.to.open) {
      poslength += options.capLength * options.unit - options.arrowLength;
    }
    negunits = options.zero - options.from.end;
    negticks = (function() {
      var _i, _ref1, _ref2, _ref3, _results;
      _results = [];
      for (n = _i = _ref1 = options.from.end, _ref2 = options.zero, _ref3 = options.step; _ref1 <= _ref2 ? _i < _ref2 : _i > _ref2; n = _i += _ref3) {
        _results.push(n);
      }
      return _results;
    })();
    neglength = negunits * options.unit;
    if (options.from.open) {
      neglength += options.capLength * options.unit - options.arrowLength;
    }
    turns = τ * options.turns;
    length = neglength + poslength;
    ux = Math.cos(turns);
    uy = Math.sin(turns);
    sx = zx - (neglength * ux);
    sy = zy + (neglength * uy);
    ex = zx + (poslength * ux);
    ey = zy - (poslength * uy);
    hasPath = (_ref1 = options.tickType) === 'T' || _ref1 === 'L' || _ref1 === '+';
    if (hasPath) {
      path = paper.path(['M', sx, sy, 'L', ex, ey]);
      $(path.node).attr({
        'class': "" + options.classes + " " + options.lineClass
      });
    }
    label = function(number) {
      if (_.has(options.labels, number)) {
        return options.labels[number];
      } else {
        return number;
      }
    };
    tick = function(cx, cy, number, zero) {
      var bottom, botx, boty, factor, full, textx, texty, tickLabel, tickLine, toff, top, topx, topy, _ref2;
      if (zero == null) {
        zero = false;
      }
      full = (_ref2 = options.tickType) === '|' || _ref2 === '+';
      factor = 1;
      if (zero && full) {
        factor = options.zeroTick;
      } else if (zero) {
        full = true;
        factor = 2;
      }
      if (full) {
        top = factor * 1 / 2;
        bottom = factor * 1 / 2;
      } else if (options.tickType === 'L') {
        top = factor;
        bottom = 0;
      } else {
        top = 0;
        bottom = factor;
      }
      topx = cx - (options.tickHeight * top * uy);
      topy = cy - (options.tickHeight * top * ux);
      botx = cx + (options.tickHeight * bottom * uy);
      boty = cy + (options.tickHeight * bottom * ux);
      toff = options.tickHeight + options.textOffset;
      if (options.swapLabels) {
        toff *= -1;
      }
      textx = cx + (toff * uy);
      texty = cy + (toff * ux);
      tickLabel = paper.text(textx, texty, label(number));
      $(tickLabel.node).attr({
        "class": "" + options.classes + " " + options.labelClass
      });
      if (options.tickType !== ' ') {
        tickLine = paper.path(['M', topx, topy, 'L', botx, boty]);
        return $(tickLine.node).attr({
          "class": "" + options.classes + " " + options.tickClass
        });
      }
    };
    for (position = _i = 0, _len = negticks.length; _i < _len; position = ++_i) {
      number = negticks[position];
      tx = zx - ((position + 1) * options.unit * ux);
      ty = zy + ((position + 1) * options.unit * uy);
      tick(tx, ty, number);
    }
    tick(zx, zy, options.zero, true);
    for (position = _j = 0, _len1 = posticks.length; _j < _len1; position = ++_j) {
      number = posticks[position];
      tx = zx + ((position + 1) * options.unit * ux);
      ty = zy - ((position + 1) * options.unit * uy);
      tick(tx, ty, number);
    }
    cap = function(cx, cy, invert) {
      var arrow, db, dl;
      if (invert == null) {
        invert = false;
      }
      dl = invert ? -options.arrowLength : options.arrowLength;
      db = options.arrowBreadth;
      arrow = paper.path(['M', cx + dl * ux, cy - dl * uy, cx - db * uy, cy - db * ux, cx + db * uy, cy + db * ux, 'z']);
      return $(arrow.node).attr({
        "class": "" + options.classes + " " + options.arrowClass
      });
    };
    if (options.from.open) {
      cap(sx, sy, true);
    }
    if (options.to.open) {
      return cap(ex, ey);
    }
  };

  this.Diagram = (function() {

    function Diagram(elem, width, height) {
      var aspect, trueWidth;
      this.elem = elem;
      this.axis = __bind(this.axis, this);

      this.elem = $(elem);
      trueWidth = this.elem.width();
      aspect = height / width;
      this.paper = new Raphael(elem, trueWidth, trueWidth * aspect);
      this.paper.customAttributes.partialCircle = function(x, y, r, turns, yaw) {
        var path;
        path = partialCircle(x, y, r, turns, yaw);
        return {
          path: path.string
        };
      };
      this.paper.customAttributes.turnRotate = function(x, y, uplen, downlen, turns) {
        return {
          path: turnRotate(x, y, uplen, downlen, turns).string
        };
      };
      this.paper.customAttributes.turnText = function(turns) {
        return {
          text: (τ * turns).toFixed(6)
        };
      };
      this.paper.setViewBox(0, 0, width, height);
    }

    Diagram.prototype.path = function(attrs) {
      return applyAttrs(this.paper.path(), attrs);
    };

    Diagram.prototype.axis = function(zx, zy, options) {
      return axis(this.paper, zx, zy, options);
    };

    return Diagram;

  })();

  this.diagram = function(codename, cls, w, h) {
    return $("." + codename).each(function() {
      return new cls(this, w, h).start();
    });
  };

}).call(this);
