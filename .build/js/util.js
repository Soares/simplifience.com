// Generated by CoffeeScript 1.4.0
(function() {
  var applyAttrs, axis, capArrow, mathText, partialCircle, rotatedLine, tspan, turnRotate,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.τ = 2 * Math.PI;

  this.callbackAfter = function(fn, delay) {
    return function() {
      return setTimeout(fn, delay);
    };
  };

  this.Bound = (function() {

    function Bound(end, open) {
      this.end = end;
      this.open = open != null ? open : true;
    }

    return Bound;

  })();

  this.Path = (function() {

    function Path(x, y) {
      this.arc = __bind(this.arc, this);

      this.symmetricArc = __bind(this.symmetricArc, this);

      this.move = __bind(this.move, this);

      this.draw = __bind(this.draw, this);
      this.string = "M " + x + " " + y;
    }

    Path.prototype.draw = function(x, y, options) {
      var letter;
      letter = (options != null ? options.absolute : void 0) ? 'L' : 'l';
      this.string += "" + letter + " " + x + " " + y;
      return this;
    };

    Path.prototype.move = function(x, y, options) {
      var letter;
      letter = (options != null ? options.absolute : void 0) ? 'M' : 'm';
      this.string += "" + letter + " " + x + " " + y;
      return this;
    };

    Path.prototype.symmetricArc = function(x, y, r, options) {
      this.arc(x, y, r, r, 0, options);
      return this;
    };

    Path.prototype.arc = function(x, y, rx, ry, theta, options) {
      var invert, large, letter;
      large = +((options != null ? options.large : void 0) || 0);
      invert = +((options != null ? options.invert : void 0) || 0);
      letter = (options != null ? options.absolute : void 0) ? 'A' : 'a';
      this.string += "" + letter + " " + rx + " " + ry + " " + theta + " " + large + " " + invert + " " + x + " " + y;
      return this;
    };

    return Path;

  })();

  partialCircle = function(cx, cy, r, turns, yaw) {
    var x1, x2, y1, y2;
    yaw = yaw || 0;
    x1 = cx + (r * Math.cos(yaw * τ));
    y1 = cy - (r * Math.sin(yaw * τ));
    x2 = cx + (r * Math.cos((yaw + turns) * τ));
    y2 = cy - (r * Math.sin((yaw + turns) * τ));
    return new Path(x1, y1).symmetricArc(x2, y2, r, {
      large: turns > 0.5,
      absolute: true
    });
  };

  rotatedLine = function(sx, sy, r, turns) {
    var dx, dy;
    dx = r * Math.cos(turns * τ);
    dy = -r * Math.sin(turns * τ);
    return new Path(sx, sy).draw(dx, dy);
  };

  turnRotate = function(cx, cy, uplen, downlen, turns) {
    var h, v, x1, x2, y1, y2;
    h = Math.cos(τ * turns);
    v = -Math.sin(τ * turns);
    x1 = cx + uplen * h;
    y1 = cy + uplen * v;
    x2 = cx - downlen * h;
    y2 = cy - downlen * v;
    return new Path(x1, y1).draw(x2, y2, {
      absolute: true
    });
  };

  applyAttrs = function(obj, attrs) {
    var node;
    node = $(obj.node);
    if (attrs == null) {
      attrs = {};
    }
    if (_.isArray(attrs["class"])) {
      node.attr('class', attrs["class"].join(' '));
    } else if (_.isString(attrs["class"])) {
      node.attr('class', attrs["class"]);
    }
    delete attrs["class"];
    if (_.isString(attrs.style)) {
      node.attr('style', attrs.style);
    }
    delete attrs.style;
    if (!_.isEmpty(attrs)) {
      obj.attr(attrs);
    }
    return obj;
  };

  tspan = function(part) {
    var key, node, val;
    node = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
    if (_.isObject(part)) {
      node.appendChild(document.createTextNode(part.text));
      delete part.text;
      for (key in part) {
        val = part[key];
        node.setAttribute(key, val);
      }
    } else {
      node.appendChild(document.createTextNode(part));
    }
    return node;
  };

  mathText = function(paper, x, y, parts, attrs) {
    var elem;
    if (_.isArray(parts)) {
      elem = paper.text(x, y, '');
      _.each(parts, function(part) {
        return elem.node.appendChild(tspan(part));
      });
    } else {
      elem = paper.text(x, y, parts);
    }
    elem.node.removeAttribute('style');
    return applyAttrs(elem, attrs);
  };

  axis = function(paper, zx, zy, options) {
    var cap, ex, ey, geometry, hasPath, label, labels, length, n, neglength, negticks, negunits, number, path, position, poslength, posticks, posunits, stepWidth, sx, sy, tick, turns, tx, ty, ux, uy, _i, _j, _len, _len1, _ref, _ref1;
    options = _.defaults(options || {}, {
      arrowBreadth: 1 / 2,
      arrowClass: 'arrow',
      arrowLength: 2,
      capLength: 1,
      classes: ['axis'],
      doTick: true,
      from: null,
      labelClass: '',
      labels: {},
      lineClass: '',
      step: 1,
      swapLabels: false,
      textOffset: 7,
      tickClass: 'tick',
      tickHeight: 4,
      tickType: 'T',
      to: new Bound(10, true),
      turns: 0,
      unit: 10,
      zero: 0,
      zeroTick: true,
      zeroLabel: true
    });
    geometry = paper.set();
    labels = paper.set();
    options.zero = +options.zero;
    if (options.from == null) {
      options.from = new Bound(options.zero, false);
    }
    if (_.isNumber(options.from)) {
      options.from = new Bound(options.from);
    }
    if (_.isNumber(options.to)) {
      options.to = new Bound(options.to);
    }
    if (_.isArray(options.classes)) {
      options.classes = options.classes.join(' ');
    }
    if (_.isBoolean(options.zeroTick) && ((_ref = options.tickType) === '|' || _ref === '+')) {
      options.zeroTick = options.zeroTick ? 1.5 : 1;
    }
    options.arrowBreadth = options.arrowBreadth * options.tickHeight;
    options.arrowLength = options.arrowLength * options.tickHeight;
    stepWidth = options.unit * options.step;
    posunits = options.to.end - options.zero;
    posticks = ((function() {
      var _i, _ref1, _ref2, _ref3, _results;
      _results = [];
      for (n = _i = _ref1 = options.zero, _ref2 = options.to.end, _ref3 = options.step; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; n = _i += _ref3) {
        _results.push(n);
      }
      return _results;
    })()).slice(1);
    poslength = posunits * options.unit;
    if (options.to.open) {
      poslength += options.capLength * options.unit - options.arrowLength;
    }
    negunits = options.zero - options.from.end;
    negticks = (function() {
      var _i, _ref1, _ref2, _ref3, _results;
      _results = [];
      for (n = _i = _ref1 = options.from.end, _ref2 = options.zero, _ref3 = options.step; _ref1 <= _ref2 ? _i < _ref2 : _i > _ref2; n = _i += _ref3) {
        _results.push(n);
      }
      return _results;
    })();
    neglength = negunits * options.unit;
    if (options.from.open) {
      neglength += options.capLength * options.unit - options.arrowLength;
    }
    turns = τ * options.turns;
    length = neglength + poslength;
    ux = Math.cos(turns);
    uy = Math.sin(turns);
    sx = zx - (neglength * ux);
    sy = zy + (neglength * uy);
    ex = zx + (poslength * ux);
    ey = zy - (poslength * uy);
    hasPath = (_ref1 = options.tickType) === 'T' || _ref1 === 'L' || _ref1 === '+' || _ref1 === false;
    if (hasPath) {
      path = paper.path(['M', sx, sy, 'L', ex, ey]);
      $(path.node).attr({
        'class': "" + options.classes + " " + options.lineClass
      });
      geometry.push(path);
    }
    label = function(tx, ty, number) {
      var elem, elemAttrs, labelParts;
      if (options.labels === false) {
        return;
      }
      labelParts = _.isFunction(options.labels) ? options.labels(number) : _.has(options.labels, number) ? options.labels[number] : number;
      if (!(labelParts != null)) {
        return;
      }
      elemAttrs = {
        "class": "" + options.classes + " " + options.labelClass
      };
      elem = mathText(paper, tx, ty, labelParts, elemAttrs);
      return labels.push(elem);
    };
    tick = function(cx, cy, number, zero) {
      var bottom, botx, boty, factor, full, textx, texty, tickLine, toff, top, topx, topy, _ref2;
      if (zero == null) {
        zero = false;
      }
      if (zero && options.zeroTick === 0) {
        return;
      }
      if (_.isFunction(options.doTick) && !options.doTick(number)) {
        return;
      }
      if (options.tickType === ' ') {
        textx = cx + options.textOffset * uy;
        texty = cy + options.textOffset * ux;
        if (!(zero && !options.zeroLabel)) {
          label(textx, texty, number);
        }
        return;
      }
      if (options.tickType === false) {
        return;
      }
      full = (_ref2 = options.tickType) === '|' || _ref2 === '+';
      factor = 1;
      if (zero && full) {
        factor = options.zeroTick;
      } else if (zero && options.zeroTick) {
        full = true;
        factor = 2;
      }
      if (full) {
        top = factor * 1 / 2;
        bottom = factor * 1 / 2;
      } else if (options.tickType === 'L') {
        top = factor;
        bottom = 0;
      } else {
        top = 0;
        bottom = factor;
      }
      topx = cx - (options.tickHeight * top * uy);
      topy = cy - (options.tickHeight * top * ux);
      botx = cx + (options.tickHeight * bottom * uy);
      boty = cy + (options.tickHeight * bottom * ux);
      toff = options.tickHeight + options.textOffset;
      if (options.swapLabels) {
        toff *= -1;
      }
      textx = cx + (toff * uy);
      texty = cy + (toff * ux);
      if (!(zero && !options.zeroLabel)) {
        label(textx, texty, number);
      }
      tickLine = paper.path(['M', topx, topy, 'L', botx, boty]);
      $(tickLine.node).attr({
        "class": "" + options.classes + " " + options.tickClass
      });
      return geometry.push(tickLine);
    };
    for (position = _i = 0, _len = negticks.length; _i < _len; position = ++_i) {
      number = negticks[position];
      tx = zx - ((negticks.length - position) * stepWidth * ux);
      ty = zy + ((negticks.length - position) * stepWidth * uy);
      tick(tx, ty, number);
    }
    tick(zx, zy, options.zero, true);
    for (position = _j = 0, _len1 = posticks.length; _j < _len1; position = ++_j) {
      number = posticks[position];
      tx = zx + ((position + 1) * stepWidth * ux);
      ty = zy - ((position + 1) * stepWidth * uy);
      tick(tx, ty, number);
    }
    cap = function(cx, cy, invert) {
      var arrow, db, dl;
      if (invert == null) {
        invert = false;
      }
      dl = invert ? -options.arrowLength : options.arrowLength;
      db = options.arrowBreadth;
      arrow = paper.path(['M', cx + dl * ux, cy - dl * uy, cx - db * uy, cy - db * ux, cx + db * uy, cy + db * ux, 'z']);
      $(arrow.node).attr({
        "class": "" + options.classes + " " + options.arrowClass
      });
      return geometry.push(arrow);
    };
    if (options.from.open) {
      cap(sx, sy, true);
    }
    if (options.to.open) {
      cap(ex, ey);
    }
    return [geometry, labels];
  };

  this.Diagram = (function() {

    function Diagram(elem, width, height) {
      var aspect, trueWidth;
      this.elem = elem;
      this.text = __bind(this.text, this);

      this.axis = __bind(this.axis, this);

      this.elem = $(elem);
      trueWidth = this.elem.width();
      aspect = height / width;
      this.paper = new Raphael(elem, trueWidth, trueWidth * aspect);
      this.paper.customAttributes.partialCircle = function(x, y, r, turns, yaw) {
        var path;
        path = partialCircle(x, y, r, turns, yaw);
        return {
          path: path.string
        };
      };
      this.paper.customAttributes.turnRotate = function(x, y, uplen, downlen, turns) {
        return {
          path: turnRotate(x, y, uplen, downlen, turns).string
        };
      };
      this.paper.customAttributes.turnText = function(turns) {
        return {
          text: (τ * turns).toFixed(6)
        };
      };
      this.paper.setViewBox(0, 0, width, height);
    }

    Diagram.prototype.circle = function(attrs) {
      return applyAttrs(this.paper.circle(), attrs);
    };

    Diagram.prototype.path = function(attrs) {
      return applyAttrs(this.paper.path(), attrs);
    };

    Diagram.prototype.axis = function(zx, zy, options) {
      return axis(this.paper, zx, zy, options);
    };

    Diagram.prototype.text = function(x, y, parts, attrs) {
      return mathText(this.paper, x, y, parts, attrs);
    };

    return Diagram;

  })();

  this.diagram = function(codename, cls, w, h) {
    return $("." + codename).each(function() {
      return new cls(this, w, h).start();
    });
  };

  this.Tick = (function() {

    function Tick(paper, x, y, turns, height, full) {
      this.paper = paper;
      this.x = x;
      this.y = y;
      this.turns = turns;
      this.height = height;
      this.full = full;
      this.path = __bind(this.path, this);

      this.larger = __bind(this.larger, this);

    }

    Tick.prototype.larger = function(scale) {
      if (this.full) {
        return this.height *= scale;
      } else {
        return this.full = true;
      }
    };

    Tick.prototype.path = function() {
      var botx, boty, topx, topy, u, v;
      u = Math.cos(τ * this.turns);
      v = Math.sin(τ * this.turns);
      if (this.full) {
        topx = this.x - this.height * v;
        topy = this.y + this.height * u;
      } else {
        topx = this.x;
        topy = this.y;
      }
      botx = this.x + this.height * v;
      boty = this.y + this.height * u;
      return this.paper.path(['M', topx, topy, 'L', botx, boty]);
    };

    return Tick;

  })();

  this.Axis = (function() {

    function Axis(paper, x0, y0, options) {
      var extensionLength, n, neglength, negunits, poslength, posunits, _i, _len, _ref, _ref1;
      this.paper = paper;
      this.x0 = x0;
      this.y0 = y0;
      if (options == null) {
        options = {};
      }
      this.classify = __bind(this.classify, this);

      this.label = __bind(this.label, this);

      this.tick = __bind(this.tick, this);

      this.ticks = __bind(this.ticks, this);

      this.arrow = __bind(this.arrow, this);

      this.line = __bind(this.line, this);

      this.point = __bind(this.point, this);

      options = _.defaults(options, {
        adjustTick: (function(num, type) {
          if (num === options.zero) {
            if (type === 'full') {
              return [1.5, 'full'];
            } else {
              return [1, 'full'];
            }
          } else {
            return [1, type];
          }
        }),
        arrowDimensions: [1, 1 / 2],
        capLength: 1,
        classes: {},
        from: null,
        labels: {},
        step: 1,
        swapLabels: false,
        textOffset: 7,
        tickHeight: 4,
        tickType: 'bottom',
        drawLine: true,
        to: new Bound(10, true),
        turns: 0,
        unit: 10,
        zero: 0
      });
      this.classes = _.defaults(options.classes, {
        all: 'axis',
        positive: 'positive',
        zero: 'zero',
        negative: 'negative',
        arrow: 'arrow',
        axis: null
      });
      this.elements = {
        geometry: paper.set(),
        ticks: paper.set(),
        arrows: paper.set(),
        labels: paper.set()
      };
      this.unit = options.unit;
      this.zero = options.zero;
      this.tickHeight = options.tickHeight;
      this.tickType = options.tickType;
      if ((_ref = options.from) == null) {
        options.from = new Bound(this.zero, false);
      }
      if (_.isNumber(options.from)) {
        options.from = new Bound(options.from);
      }
      if (_.isNumber(options.to)) {
        options.to = new Bound(options.to);
      }
      if (options.arrowDimensions) {
        this.arrowLength = options.arrowDimensions[0] * options.tickHeight;
        this.arrowBreadth = options.arrowDimensions[1] * options.tickHeight;
      } else {
        this.arrowLength = 0;
        this.arrowBreadth = 0;
      }
      this.asmuth = Math.cos(τ * options.turns);
      this.attitude = Math.sin(τ * options.turns);
      extensionLength = capLength * this.unit - this.arrowLength;
      posunits = to.end - this.zero;
      negunits = this.zero - from.end;
      poslength = posunits * this.unit;
      if (to.open) {
        poslength += extensionLength;
      }
      neglength = negunits * this.unit;
      if (from.open) {
        negLength += extensionLength;
      }
      this.start = this.point(neglength);
      this.end = this.point(poslength);
      if (options.drawLine) {
        this.line;
      }
      if (options.from.open) {
        this.arrow(options.from.end);
      }
      if (options.to.open) {
        this.arrow(options.to.end);
      }
      _ref1 = this.ticks(options.from.end, options.to.end, options.step);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        n = _ref1[_i];
        this.tick(n, options.adjustTick, {
          lookup: options.labels,
          swap: options.swapLabels,
          offset: options.textOffset
        });
      }
    }

    Axis.prototype.point = function(length) {
      return [this.x0 + this.asmuth * length * this.unit, this.y0 - this.attitude * length * this.unit];
    };

    Axis.prototype.line = function() {
      this.elements.axis = paper.path(['M'] + this.start + ['L'] + this.end);
      this.classify(this.elements.axis, 'axis');
      return this.elements.geometry.push(this.elements.axis);
    };

    Axis.prototype.arrow = function(n) {
      var length, path, x, y, _ref;
      _ref = n > this.zero ? this.end : this.start, x = _ref[0], y = _ref[1];
      length = (n > this.zero ? 1 : -1) * this.arrowLength;
      path = paper.path(['M', x + length * this.asmuth, y - length * this.attitude, x - this.arrowBreadth * this.attitude, y - this.arrowBreadth * this.asmuth, x + this.arrowBreadth * this.attitude, y + this.arrowBreadth * this.asmuth, 'z']);
      this.classify(path, 'arrow', n);
      this.elements.arrows.push(path);
      return this.elements.geometry.push(path);
    };

    Axis.prototype.ticks = function(from, to, step) {
      var n, _i, _j, _results, _results1;
      if (_.isNumber(step)) {
        _results = [];
        for (n = _i = from; from <= to ? _i <= to : _i >= to; n = _i += step) {
          _results.push(n);
        }
        return _results;
      } else {
        _results1 = [];
        for (n = _j = from; from <= to ? _j <= to : _j >= to; n = from <= to ? ++_j : --_j) {
          if (step(n)) {
            _results1.push(n);
          }
        }
        return _results1;
      }
    };

    Axis.prototype.tick = function(n, adjust, labelOptions) {
      var bottom, dx, dy, factor, path, tip, top, type, x, y, _ref, _ref1;
      if (this.tickType === false) {
        return;
      }
      _ref = _.isFunction(adjust) ? adjust(n, this.tickType) : [1, this.tickType], factor = _ref[0], type = _ref[1];
      _ref1 = this.point(n - this.zero), x = _ref1[0], y = _ref1[1];
      dx = this.tickHeight * factor * this.attitude;
      dy = this.tickHeight * factor * this.asmuth;
      top = type === 'full' || type === 'top' ? [x - dx, y + dy] : [x, y];
      bottom = type === 'full' || type === 'bottom' ? [x + dx, y - dy] : [x, y];
      path = this.paper.path(['M'] + top + ['L'] + bottom);
      this.classify(path, 'tick', n);
      this.elements.ticks.push(path);
      this.elements.geometry.push(path);
      tip = labelOptions.swap ? top : bottom;
      return this.label(n, tip, labelOptions.lookup, labelOptions.offset);
    };

    Axis.prototype.label = function(n, point, lookup, getOffset) {
      var label, offset, text, x, y;
      if (lookup === false) {
        return;
      }
      label = _.isFunction(lookup) ? lookup(label) : _.has(lookup, n) ? lookup[n] : n;
      if (!(label != null)) {
        return;
      }
      offset = _.isFunction(getOffset) ? getOffset(n) : getOffset;
      x = point[0] + offset * this.attitude;
      y = point[1] + offset * this.asmuth;
      text = Text(this.paper, x, y, label);
      this.classify(text, 'label', n);
      return this.elements.labels.push(text);
    };

    Axis.prototype.classify = function(el, type, n) {
      var classes, extra;
      if (n == null) {
        n = null;
      }
      extra = [];
      if (n === this.zero) {
        extra.push('zero');
      }
      if (n < this.zero) {
        extra.push('negative');
      }
      if (n > this.zero) {
        extra.push('positive');
      }
      classes = _.flatten(this.classes.all, this.classes[type], extra);
      return el.node.setAttribute('class', classes.join(' '));
    };

    return Axis;

  })();

  axis = function(paper, zx, zy, options) {
    var cap, ex, ey, geometry, hasPath, label, labels, length, n, neglength, negticks, negunits, number, path, position, poslength, posticks, posunits, stepWidth, sx, sy, tick, turns, tx, ty, ux, uy, _i, _j, _len, _len1, _ref, _ref1;
    options = _.defaults(options || {}, {
      arrowBreadth: 1 / 2,
      arrowClass: 'arrow',
      arrowLength: 2,
      capLength: 1,
      classes: ['axis'],
      doTick: true,
      from: null,
      labelClass: '',
      labels: {},
      lineClass: '',
      step: 1,
      swapLabels: false,
      textOffset: 7,
      tickClass: 'tick',
      tickHeight: 4,
      tickType: 'T',
      to: new Bound(10, true),
      turns: 0,
      unit: 10,
      zero: 0,
      zeroTick: true,
      zeroLabel: true
    });
    geometry = paper.set();
    labels = paper.set();
    options.zero = +options.zero;
    if (options.from == null) {
      options.from = new Bound(options.zero, false);
    }
    if (_.isNumber(options.from)) {
      options.from = new Bound(options.from);
    }
    if (_.isNumber(options.to)) {
      options.to = new Bound(options.to);
    }
    if (_.isArray(options.classes)) {
      options.classes = options.classes.join(' ');
    }
    if (_.isBoolean(options.zeroTick) && ((_ref = options.tickType) === '|' || _ref === '+')) {
      options.zeroTick = options.zeroTick ? 1.5 : 1;
    }
    options.arrowBreadth = options.arrowBreadth * options.tickHeight;
    options.arrowLength = options.arrowLength * options.tickHeight;
    stepWidth = options.unit * options.step;
    posunits = options.to.end - options.zero;
    posticks = ((function() {
      var _i, _ref1, _ref2, _ref3, _results;
      _results = [];
      for (n = _i = _ref1 = options.zero, _ref2 = options.to.end, _ref3 = options.step; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; n = _i += _ref3) {
        _results.push(n);
      }
      return _results;
    })()).slice(1);
    poslength = posunits * options.unit;
    if (options.to.open) {
      poslength += options.capLength * options.unit - options.arrowLength;
    }
    negunits = options.zero - options.from.end;
    negticks = (function() {
      var _i, _ref1, _ref2, _ref3, _results;
      _results = [];
      for (n = _i = _ref1 = options.from.end, _ref2 = options.zero, _ref3 = options.step; _ref1 <= _ref2 ? _i < _ref2 : _i > _ref2; n = _i += _ref3) {
        _results.push(n);
      }
      return _results;
    })();
    neglength = negunits * options.unit;
    if (options.from.open) {
      neglength += options.capLength * options.unit - options.arrowLength;
    }
    turns = τ * options.turns;
    length = neglength + poslength;
    ux = Math.cos(turns);
    uy = Math.sin(turns);
    sx = zx - (neglength * ux);
    sy = zy + (neglength * uy);
    ex = zx + (poslength * ux);
    ey = zy - (poslength * uy);
    hasPath = (_ref1 = options.tickType) === 'T' || _ref1 === 'L' || _ref1 === '+' || _ref1 === false;
    if (hasPath) {
      path = paper.path(['M', sx, sy, 'L', ex, ey]);
      $(path.node).attr({
        'class': "" + options.classes + " " + options.lineClass
      });
      geometry.push(path);
    }
    label = function(tx, ty, number) {
      var elem, elemAttrs, labelParts;
      if (options.labels === false) {
        return;
      }
      labelParts = _.isFunction(options.labels) ? options.labels(number) : _.has(options.labels, number) ? options.labels[number] : number;
      if (!(labelParts != null)) {
        return;
      }
      elemAttrs = {
        "class": "" + options.classes + " " + options.labelClass
      };
      elem = mathText(paper, tx, ty, labelParts, elemAttrs);
      return labels.push(elem);
    };
    tick = function(cx, cy, number, zero) {
      var bottom, botx, boty, factor, full, textx, texty, tickLine, toff, top, topx, topy, _ref2;
      if (zero == null) {
        zero = false;
      }
      if (zero && options.zeroTick === 0) {
        return;
      }
      if (_.isFunction(options.doTick) && !options.doTick(number)) {
        return;
      }
      if (options.tickType === ' ') {
        textx = cx + options.textOffset * uy;
        texty = cy + options.textOffset * ux;
        if (!(zero && !options.zeroLabel)) {
          label(textx, texty, number);
        }
        return;
      }
      if (options.tickType === false) {
        return;
      }
      full = (_ref2 = options.tickType) === '|' || _ref2 === '+';
      factor = 1;
      if (zero && full) {
        factor = options.zeroTick;
      } else if (zero && options.zeroTick) {
        full = true;
        factor = 2;
      }
      if (full) {
        top = factor * 1 / 2;
        bottom = factor * 1 / 2;
      } else if (options.tickType === 'L') {
        top = factor;
        bottom = 0;
      } else {
        top = 0;
        bottom = factor;
      }
      topx = cx - (options.tickHeight * top * uy);
      topy = cy - (options.tickHeight * top * ux);
      botx = cx + (options.tickHeight * bottom * uy);
      boty = cy + (options.tickHeight * bottom * ux);
      toff = options.tickHeight + options.textOffset;
      if (options.swapLabels) {
        toff *= -1;
      }
      textx = cx + (toff * uy);
      texty = cy + (toff * ux);
      if (!(zero && !options.zeroLabel)) {
        label(textx, texty, number);
      }
      tickLine = paper.path(['M', topx, topy, 'L', botx, boty]);
      $(tickLine.node).attr({
        "class": "" + options.classes + " " + options.tickClass
      });
      return geometry.push(tickLine);
    };
    for (position = _i = 0, _len = negticks.length; _i < _len; position = ++_i) {
      number = negticks[position];
      tx = zx - ((negticks.length - position) * stepWidth * ux);
      ty = zy + ((negticks.length - position) * stepWidth * uy);
      tick(tx, ty, number);
    }
    tick(zx, zy, options.zero, true);
    for (position = _j = 0, _len1 = posticks.length; _j < _len1; position = ++_j) {
      number = posticks[position];
      tx = zx + ((position + 1) * stepWidth * ux);
      ty = zy - ((position + 1) * stepWidth * uy);
      tick(tx, ty, number);
    }
    cap = function(cx, cy, invert) {
      var arrow;
      if (invert == null) {
        invert = false;
      }
      length = invert ? -options.arrowLength : options.arrowLength;
      arrow = capArrow(paper, cx, cy, options.turns, length, options.arrowBreadth);
      $(arrow.node).attr({
        "class": "" + options.classes + " " + options.arrowClass
      });
      return geometry.push(arrow);
    };
    if (options.from.open) {
      cap(sx, sy, true);
    }
    if (options.to.open) {
      cap(ex, ey);
    }
    return [geometry, labels];
  };

  capArrow = function(paper, x, y, turns, length, breadth) {
    var u, v;
    u = Math.cos(τ * turns);
    v = Math.sin(τ * turns);
    return paper.path(['M', x + length * u, y - length * v, x - breadth * v, y - breadth * u, x + breadth * v, y + breadth * u, 'z']);
  };

}).call(this);
