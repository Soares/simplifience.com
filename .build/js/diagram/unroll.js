// Generated by CoffeeScript 1.4.0
(function() {
  var Unroller, circumference, height, middle, padding, radius, tx, ty, width, zx, zy,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  width = 500;

  height = 200;

  radius = 45;

  padding = 5;

  circumference = Ï„ * radius;

  middle = height / 2;

  zx = padding + radius;

  zy = middle + radius;

  tx = width - 2 * radius;

  ty = radius;

  Unroller = (function(_super) {

    __extends(Unroller, _super);

    function Unroller() {
      this.wait = __bind(this.wait, this);

      this.fadeOut = __bind(this.fadeOut, this);

      this.pause = __bind(this.pause, this);

      this.roll = __bind(this.roll, this);

      this.fadeIn = __bind(this.fadeIn, this);

      this.begin = __bind(this.begin, this);

      this.reset = __bind(this.reset, this);

      this.start = __bind(this.start, this);
      return Unroller.__super__.constructor.apply(this, arguments);
    }

    Unroller.prototype.start = function() {
      var capFraction, counter, tickCount;
      this.isDiameterLine = this.elem.data('diameter') || false;
      this.stopEarly = this.elem.data('pistop') || false;
      counter = this.elem.data('counter') || false;
      this.lineLength = this.isDiameterLine ? 2 * radius : radius;
      tickCount = this.isDiameterLine ? 4 : 8;
      capFraction = this.isDiameterLine ? 1 / 2 : 1;
      this.axis(zx - 0.5, zy, this.lineLength, tickCount, {
        capFraction: capFraction
      });
      this.circle = this.paper.circle();
      this.outline = this.paper.path().attr({
        'stroke-width': 2
      });
      $(this.outline.node).attr({
        'class': 'colored',
        'style': 'fill:none'
      });
      this.laid = this.paper.path().attr('stroke-width', 2);
      $(this.laid.node).attr('class', 'colored');
      this.line = this.paper.path().attr('stroke-width', 1);
      $(this.line.node).attr('class', 'colored');
      this.counter = counter ? this.paper.text(tx, ty, 0..toFixed(6)) : false;
      this.reset();
      return setTimeout(this.begin, 3000);
    };

    Unroller.prototype.reset = function() {
      var _ref;
      this.circle.attr({
        cx: zx,
        cy: zy - radius,
        r: radius,
        opacity: 0,
        'stroke-width': 2,
        transform: ''
      });
      this.outline.attr({
        partialCircle: [zx, zy - radius, radius, .9999, -1 / 4],
        opacity: 0
      });
      this.laid.attr({
        path: new Path(zx, zy).draw(0.01, 0).string
      });
      this.line.attr({
        opacity: 1,
        path: new Path(zx + 0.5, zy).draw(this.lineLength, 0).string
      });
      return (_ref = this.counter) != null ? typeof _ref.attr === "function" ? _ref.attr({
        turnText: 0,
        opacity: 0
      }) : void 0 : void 0;
    };

    Unroller.prototype.begin = function() {
      this.reset();
      return this.line.animate({
        transform: "r-90 " + (zx + 0.5) + " " + zy
      }, 1000, '<>', this.fadeIn);
    };

    Unroller.prototype.fadeIn = function() {
      var a, uplen, _ref;
      a = this.circle.animate({
        opacity: 1
      }, 1000, '<', this.roll);
      if ((_ref = this.counter) != null) {
        if (typeof _ref.animateWith === "function") {
          _ref.animateWith(this.circle, a, {
            opacity: 1
          }, 1000, '<');
        }
      }
      uplen = this.isDiameterLine ? radius : 0;
      return this.line.attr({
        transform: '',
        turnRotate: [zx, zy - radius, radius, uplen, -1 / 4]
      });
    };

    Unroller.prototype.roll = function() {
      var a, distance, duration, ease, turns, uplen, _ref;
      this.circle.attr({
        'stroke-width': 0
      });
      this.outline.attr({
        opacity: 1
      });
      this.laid.attr({
        opacity: 1
      });
      ease = this.stopEarly ? '<' : '<>';
      duration = this.stopEarly ? 2500 : 5000;
      uplen = this.isDiameterLine ? radius : 0;
      turns = this.stopEarly ? 1 / 2 : 1;
      distance = turns * circumference;
      a = this.circle.animate({
        transform: "t" + distance + " 0"
      }, duration, ease, this.pause);
      this.line.animateWith(this.circle, a, {
        turnRotate: [zx + distance, zy - radius, radius, uplen, -1 / 4 - turns]
      }, duration, ease);
      this.outline.animateWith(this.circle, a, {
        partialCircle: [zx + distance, middle, radius, 1 - turns, -1 / 4]
      }, duration, ease);
      this.laid.animateWith(this.circle, a, {
        path: new Path(zx, zy).draw(distance, 0).string
      }, duration, ease);
      return (_ref = this.counter) != null ? typeof _ref.animateWith === "function" ? _ref.animateWith(this.circle, a, {
        turnText: turns
      }, duration, ease) : void 0 : void 0;
    };

    Unroller.prototype.pause = function() {
      return setTimeout(this.fadeOut, this.stopEarly ? 5500 : 3000);
    };

    Unroller.prototype.fadeOut = function() {
      var a, _ref;
      a = this.circle.animate({
        opacity: 0
      }, 1000, '<', this.wait);
      this.laid.animateWith(this.circle, a, {
        opacity: 0
      }, 1000, '<');
      this.line.animateWith(this.circle, a, {
        opacity: 0
      }, 1000, '<');
      this.outline.animateWith(this.circle, a, {
        opacity: 0
      }, 1000, '<');
      return (_ref = this.couter) != null ? _ref.animateWith(this.circle, a, {
        opacity: 0
      }, 1000, '<') : void 0;
    };

    Unroller.prototype.wait = function() {
      return setTimeout(this.begin, 1000);
    };

    return Unroller;

  })(Diagram);

  diagram('unroll', Unroller, width, height);

}).call(this);
