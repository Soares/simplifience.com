// Generated by CoffeeScript 1.4.0
(function() {
  var Unroller, horizontal, partialCircle, turnRotate, turnText,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  partialCircle = function(cx, cy, r, turns, yaw) {
    var x1, x2, y1, y2;
    yaw = yaw || 0;
    x1 = cx + (r * Math.cos(yaw * τ));
    y1 = cy - (r * Math.sin(yaw * τ));
    x2 = cx + (r * Math.cos((yaw + turns) * τ));
    y2 = cy - (r * Math.sin((yaw + turns) * τ));
    return {
      path: ['M', x1, y1, 'A', r, r, 0, +(turns > 0.5), 0, x2, y2]
    };
  };

  turnRotate = function(cx, cy, toplen, botlen, turns) {
    var h, v, x1, x2, y1, y2;
    h = Math.cos(τ * turns);
    v = -Math.sin(τ * turns);
    x1 = cx + toplen * h;
    y1 = cy + toplen * v;
    x2 = cx - botlen * h;
    y2 = cy - botlen * v;
    return {
      path: ['M', x1, y1, 'L', x2, y2]
    };
  };

  horizontal = function(x, y, distance) {
    if (distance === 0) {
      return {
        path: ['M', x, y, 'l', 0.001, 0]
      };
    } else {
      return {
        path: ['M', x, y, 'l', distance + 0.5, 0]
      };
    }
  };

  turnText = function(turns) {
    return {
      text: (τ * turns).toFixed(6)
    };
  };

  Unroller = (function(_super) {

    __extends(Unroller, _super);

    function Unroller(elem, width, height, radius, padding) {
      var circle, counter, fadeIn, fadeOut, initial, isDiameterLine, laid, line, middle, outline, preRollShuffle, roll, rollDistance, rollDuration, rollEase, rollTurns, standUp, stopEarly, toplen, turnRotateShuffle, unit, zx, zy;
      if (width == null) {
        width = 500;
      }
      if (height == null) {
        height = 200;
      }
      if (radius == null) {
        radius = 45;
      }
      if (padding == null) {
        padding = 5;
      }
      Unroller.__super__.constructor.call(this, elem, width, height);
      this.register({
        partialCircle: partialCircle,
        turnRotate: turnRotate,
        horizontal: horizontal,
        turnText: turnText
      });
      middle = height / 2;
      zx = padding + radius;
      zy = middle + radius;
      isDiameterLine = this.elem.data('diameter') || false;
      stopEarly = this.elem.data('pistop') || false;
      unit = isDiameterLine ? 2 * radius : radius;
      this.axis(zx, zy + 0.5, {
        unit: unit,
        to: isDiameterLine ? 4 : 8,
        capLength: isDiameterLine ? 1 / 2 : 1
      });
      circle = this.circle(zx, zy - radius, radius, {
        "class": 'colored'
      });
      outline = this.path(null, {
        'stroke-width': 2,
        "class": 'colored line'
      });
      laid = this.path(null, {
        'stroke-width': 2,
        "class": 'colored'
      });
      line = this.path(null, {
        'stroke-width': 1,
        "class": 'colored'
      });
      counter = this.elem.data('counter') ? this.text(width - 2 * radius, radius, 0..toFixed(6)) : false;
      toplen = isDiameterLine ? radius : 0;
      rollEase = stopEarly ? '<' : '<>';
      rollDuration = stopEarly ? 2500 : 5000;
      rollTurns = stopEarly ? 1 / 2 : 1;
      rollDistance = rollTurns * τ * radius;
      initial = [
        [
          circle, {
            opacity: 0,
            'stroke-width': 2,
            transform: ''
          }
        ], [
          outline, {
            partialCircle: [zx, zy - radius, radius, .9999, -1 / 4],
            opacity: 0
          }
        ], [
          laid, {
            horizontal: [zx, zy, 0]
          }
        ], [
          line, {
            opacity: 1,
            path: ['M', zx, zy, 'l', unit, 0]
          }
        ], [
          counter, {
            turnText: 0,
            opacity: 0
          }
        ]
      ];
      standUp = this.animate([
        [
          line, {
            transform: ['r', -90, zx, zy]
          }
        ]
      ], 1000, '<>');
      turnRotateShuffle = this.animate([
        [
          line, {
            transform: '',
            turnRotate: [zx, zy - radius, radius, toplen, -1 / 4]
          }
        ]
      ]);
      fadeIn = this.animate([
        [
          circle, {
            opacity: 1
          }
        ], [
          counter, {
            opacity: 1
          }
        ]
      ], 1000, '<');
      preRollShuffle = this.animate([
        [
          circle, {
            'stroke-width': 0
          }
        ], [
          outline, {
            opacity: 1
          }
        ], [
          laid, {
            opacity: 1
          }
        ]
      ]);
      roll = this.animate([
        [
          circle, {
            transform: ['t', rollDistance, 0]
          }
        ], [
          line, {
            turnRotate: [zx + rollDistance, zy - radius, radius + 1, toplen, -1 / 4 - rollTurns]
          }
        ], [
          outline, {
            partialCircle: [zx + rollDistance, middle, radius, 1 - rollTurns, -1 / 4]
          }
        ], [
          laid, {
            horizontal: [zx, zy, rollDistance]
          }
        ], [
          counter, {
            turnText: rollTurns
          }
        ]
      ], rollDuration, rollEase);
      fadeOut = this.animate([
        [
          circle, {
            opacity: 0
          }
        ], [
          laid, {
            opacity: 0
          }
        ], [
          line, {
            opacity: 0
          }
        ], [
          outline, {
            opacity: 0
          }
        ], [
          counter, {
            opacity: 0
          }
        ]
      ], 1000, '<');
      this.recipe(initial, [standUp, turnRotateShuffle, fadeIn, preRollShuffle, roll, stopEarly ? 5500 : 3000, fadeOut, initial], 1000).trigger(3000);
    }

    return Unroller;

  })(Uriel.Diagram);

  $(function() {
    return Uriel.diagram('unroll', Unroller);
  });

}).call(this);
