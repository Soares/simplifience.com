// Generated by CoffeeScript 1.7.1
(function() {
  var ComplexPlane, Compound, Tangents, UNIT, progression,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  UNIT = 90;

  progression = ['red', 'orange', 'gold', 'amber', 'yellow', 'celadon', 'green', 'teal', 'blue', 'navy', 'violet', 'magenta'];

  ComplexPlane = (function(_super) {
    __extends(ComplexPlane, _super);

    function ComplexPlane(elem, options) {
      if (options == null) {
        options = {};
      }
      this.makeVerticalAxis = __bind(this.makeVerticalAxis, this);
      this.makeHorizontalAxis = __bind(this.makeHorizontalAxis, this);
      this.setup = __bind(this.setup, this);
      if (options.unit == null) {
        options.unit = UNIT;
      }
      ComplexPlane.__super__.constructor.call(this, elem, options);
    }

    ComplexPlane.prototype.setup = function() {
      this.rule([1, 0], [1, 1]).element.toBack();
      this.point([1, 1], progression[0]);
      this.point([1, 0], progression[1]).dot.element.attr({
        r: 2
      });
      return this.text([1.2, 1.1], [
        '1 + 1', {
          text: 'i',
          'font-style': 'italic'
        }
      ]);
    };

    ComplexPlane.prototype.makeHorizontalAxis = function() {
      return ComplexPlane.__super__.makeHorizontalAxis.call(this, {
        from: -2,
        to: 2,
        tickType: 'full',
        capLength: 1 / 3,
        adjustTick: function(num, t) {
          if (num === (-2) || num === 2) {
            return [1 / 2, t];
          } else {
            return true;
          }
        },
        labels: function(num) {
          if (num === (-1) || num === 1) {
            return num;
          } else {
            return false;
          }
        }
      });
    };

    ComplexPlane.prototype.makeVerticalAxis = function() {
      return ComplexPlane.__super__.makeVerticalAxis.call(this, {
        from: -2,
        to: 2,
        textOffset: 10,
        capLength: 1 / 3,
        adjustTick: function(num, t) {
          if (num === (-2) || num === 2) {
            return [1 / 2, t];
          } else {
            return true;
          }
        },
        tickType: 'full',
        labels: function(num) {
          if (num === 1) {
            return {
              text: 'i',
              'font-style': 'italic'
            };
          }
          if (num === -1) {
            return {
              text: '-i',
              'font-style': 'italic'
            };
          }
          return false;
        }
      });
    };

    return ComplexPlane;

  })(Uriel.Plane);

  Compound = (function(_super) {
    __extends(Compound, _super);

    function Compound(elem) {
      this.setup = __bind(this.setup, this);
      this.draw = __bind(this.draw, this);
      this.drawAll = __bind(this.drawAll, this);
      this.scale = __bind(this.scale, this);
      var doAll, unit, _ref, _ref1, _ref2, _ref3;
      unit = parseFloat((_ref = $(elem).data('unit')) != null ? _ref : 1) * UNIT;
      Compound.__super__.constructor.call(this, elem, {
        unit: unit
      });
      if (this.elem.data('circle')) {
        this.guide(1).element.toBack();
      }
      this.factor = (_ref1 = this.elem.data('factor')) != null ? _ref1 : 1;
      this.scales = (_ref2 = this.elem.data('scales')) != null ? _ref2 : false;
      if (this.factor === 'pi') {
        this.factor = Math.PI;
      }
      this.points = this.paper.set();
      this.rules = this.paper.set();
      this.lines = this.paper.set();
      this.timeouts = [];
      this.n = this.elem.data('n');
      this.current_index = false;
      if (_.isArray(this.n)) {
        this.draw(0);
        doAll = ((function(_this) {
          return function() {
            return _this.timeouts.push(setTimeout(_this.drawAll, 1000));
          };
        })(this));
        this.elem.waypoint(doAll, {
          triggerOnce: true,
          offset: 'bottom-in-view'
        });
      } else {
        this.draw(this.n);
      }
      if ((_ref3 = this.scales) != null ? _ref3[0] : void 0) {
        this.scale(this.scales[0]);
      }
    }

    Compound.prototype.scale = function(factor) {
      var height, width, x, y;
      width = this.width / factor;
      height = this.height / factor;
      x = (this.width - width) / 2;
      y = (this.height - height) / 2;
      return this.paper.setViewBox(x, y, width, height);
    };

    Compound.prototype.drawAll = function() {
      var i;
      if (!_.isNumber(this.current_index)) {
        this.current_index = 1;
      }
      i = this.current_index;
      this.current_index = (this.current_index + 1) % this.n.length;
      return this.draw(i);
    };

    Compound.prototype.draw = function(i) {
      var elem, m, t, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;
      _ref = this.timeouts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        clearTimeout(t);
      }
      this.timeouts = [];
      _ref1 = this.points;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        elem = _ref1[_j];
        elem.remove();
      }
      _ref2 = this.rules;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        elem = _ref2[_k];
        elem.remove();
      }
      _ref3 = this.lines;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        elem = _ref3[_l];
        elem.remove();
      }
      if (this.label) {
        this.label.element.remove();
      }
      if (_.isArray(this.n)) {
        m = this.n[i];
        if ((_ref4 = this.scales) != null ? _ref4[i] : void 0) {
          this.scale(this.scales[i]);
        } else if (this.scales) {
          this.scale(1);
        }
      } else {
        m = i;
      }
      this.label = this.text([2, 2], [
        {
          text: 'n',
          'font-style': 'italic'
        }, " = " + m
      ]);
      return this.doPoint(0, new Complex(1, 0), null, m);
    };

    Compound.prototype.doPoint = function(n, prev, prevDot, m) {
      var current, doNext, index, point, t;
      if (prevDot) {
        prevDot.attr({
          r: 2
        });
      }
      current = new Complex(1, this.factor / m).pow(n);
      index = (m - n) % progression.length;
      this.rules.push(this.rule([prev.real, prev.im], [current.real, current.im]).element);
      this.points.toFront();
      point = this.point([current.real, current.im], progression[index]);
      this.points.push(point.dot.element);
      this.lines.push(point.line.element);
      t = 500 / m;
      if (!_.isNumber(this.current_index)) {
        t = 0;
      }
      if (n < m) {
        doNext = ((function(_this) {
          return function() {
            return _this.doPoint(n + 1, current, point.dot.element, m);
          };
        })(this));
      } else if (_.isNumber(this.current_index)) {
        doNext = this.drawAll;
        t += 500;
        if (this.current_index === 0) {
          t += 2000;
        }
      } else {
        doNext = false;
      }
      if (doNext) {
        return this.timeouts.push(setTimeout(doNext, t));
      }
    };

    Compound.prototype.setup = function() {};

    return Compound;

  })(ComplexPlane);

  Tangents = (function(_super) {
    __extends(Tangents, _super);

    function Tangents(elem) {
      this.makeVerticalAxis = __bind(this.makeVerticalAxis, this);
      this.makeHorizontalAxis = __bind(this.makeHorizontalAxis, this);
      this.setup = __bind(this.setup, this);
      Tangents.__super__.constructor.call(this, elem, {
        unit: UNIT
      });
    }

    Tangents.prototype.setup = function() {
      var circle, dot, dotAnim, path, radius, tangentAnim;
      this.rule([1, -3], [1, 3]);
      this.paper.ca.tangent = ((function(_this) {
        return function(turns) {
          var botOff, topOff, u, v, x, y, zx, zy, _ref, _ref1;
          if (turns === 1) {
            turns = 0;
          }
          u = Math.cos(τ * turns);
          v = Math.sin(τ * turns);
          _ref = _this.origin, zx = _ref[0], zy = _ref[1];
          _ref1 = _this.pt([u, v]), x = _ref1[0], y = _ref1[1];
          topOff = [x + (5 * v * _this.unit), y + (5 * u * _this.unit)];
          botOff = [x - (5 * v * _this.unit), y - (5 * u * _this.unit)];
          return {
            path: "M" + topOff + " L" + botOff
          };
        };
      })(this));
      radius = this.path("M" + this.origin + " L" + (this.pt([1, 0])), {
        "class": 'colored'
      });
      circle = this.circle([0, 0], 1 * UNIT, {
        "class": 'colored line'
      });
      path = this.path("M" + (this.pt([1, 3])) + " L" + (this.pt([1, -3])), {
        "class": 'teal'
      });
      path.element.attr({
        tangent: 0
      });
      dot = this.circle([1, 0], 2, {
        "class": 'teal'
      });
      dotAnim = Raphael.animation({
        transform: "R-360 " + this.origin
      }, 10000, 'linear').repeat(Infinity);
      tangentAnim = Raphael.animation({
        tangent: 1
      }, 10000, 'linear').repeat(Infinity);
      dot.element.animate(dotAnim);
      path.element.animateWith(dot.element, dotAnim, tangentAnim);
      return radius.element.animateWith(dot.element, dotAnim, dotAnim);
    };

    Tangents.prototype.makeHorizontalAxis = function() {
      return Tangents.__super__.makeHorizontalAxis.call(this, {
        from: -2,
        to: 2,
        tickType: false,
        capLength: 1 / 3,
        labels: false
      });
    };

    Tangents.prototype.makeVerticalAxis = function() {
      return Tangents.__super__.makeVerticalAxis.call(this, {
        from: -2,
        to: 2,
        capLength: 1 / 3,
        tickType: false,
        labels: false
      });
    };

    return Tangents;

  })(Uriel.Plane);

  $(function() {
    return Uriel.diagram('complex-plane', ComplexPlane);
  });

}).call(this);
